<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/auth0/node-jsonwebtoken#readme">jsonwebtoken (v7.4.0)</a>
</h1>
<h4>JSON Web Token implementation (symmetric and asymmetric)</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonwebtoken">module jsonwebtoken</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.JsonWebTokenError">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>JsonWebTokenError
            <span class="apidocSignatureSpan">(message, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.NotBeforeError">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>NotBeforeError
            <span class="apidocSignatureSpan">(message, date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.TokenExpiredError">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>TokenExpiredError
            <span class="apidocSignatureSpan">(message, expiredAt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.decode">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>decode
            <span class="apidocSignatureSpan">(jwt, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.sign">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>sign
            <span class="apidocSignatureSpan">(payload, secretOrPrivateKey, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.verify">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>verify
            <span class="apidocSignatureSpan">(jwtString, secretOrPublicKey, options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsonwebtoken.</span>JsonWebTokenError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsonwebtoken.</span>NotBeforeError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsonwebtoken.</span>TokenExpiredError.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonwebtoken.JsonWebTokenError">module jsonwebtoken.JsonWebTokenError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.JsonWebTokenError.JsonWebTokenError">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>JsonWebTokenError
            <span class="apidocSignatureSpan">(message, error)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonwebtoken.JsonWebTokenError.prototype">module jsonwebtoken.JsonWebTokenError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.JsonWebTokenError.prototype.constructor">
            function <span class="apidocSignatureSpan">jsonwebtoken.JsonWebTokenError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(message, error)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonwebtoken.NotBeforeError">module jsonwebtoken.NotBeforeError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.NotBeforeError.NotBeforeError">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>NotBeforeError
            <span class="apidocSignatureSpan">(message, date)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonwebtoken.NotBeforeError.prototype">module jsonwebtoken.NotBeforeError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.NotBeforeError.prototype.constructor">
            function <span class="apidocSignatureSpan">jsonwebtoken.NotBeforeError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(message, date)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonwebtoken.TokenExpiredError">module jsonwebtoken.TokenExpiredError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.TokenExpiredError.TokenExpiredError">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>TokenExpiredError
            <span class="apidocSignatureSpan">(message, expiredAt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonwebtoken.TokenExpiredError.prototype">module jsonwebtoken.TokenExpiredError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.TokenExpiredError.prototype.constructor">
            function <span class="apidocSignatureSpan">jsonwebtoken.TokenExpiredError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(message, expiredAt)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonwebtoken" id="apidoc.module.jsonwebtoken">module jsonwebtoken</a></h1>


    <h2>
        <a href="#apidoc.element.jsonwebtoken.JsonWebTokenError" id="apidoc.element.jsonwebtoken.JsonWebTokenError">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>JsonWebTokenError
        <span class="apidocSignatureSpan">(message, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JsonWebTokenError = function (message, error) {
  Error.call(this, message);
  Error.captureStackTrace(this, this.constructor);
  this.name = 'JsonWebTokenError';
  this.message = message;
  if (error) this.inner = error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonwebtoken.NotBeforeError" id="apidoc.element.jsonwebtoken.NotBeforeError">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>NotBeforeError
        <span class="apidocSignatureSpan">(message, date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotBeforeError = function (message, date) {
  JsonWebTokenError.call(this, message);
  this.name = 'NotBeforeError';
  this.date = date;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonwebtoken.TokenExpiredError" id="apidoc.element.jsonwebtoken.TokenExpiredError">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>TokenExpiredError
        <span class="apidocSignatureSpan">(message, expiredAt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TokenExpiredError = function (message, expiredAt) {
  JsonWebTokenError.call(this, message);
  this.name = 'TokenExpiredError';
  this.expiredAt = expiredAt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonwebtoken.decode" id="apidoc.element.jsonwebtoken.decode">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>decode
        <span class="apidocSignatureSpan">(jwt, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (jwt, options) {
  options = options || {};
  var decoded = jws.decode(jwt, options);
  if (!decoded) { return null; }
  var payload = decoded.payload;

  //try parse the payload
  if(typeof payload === 'string') {
    try {
      var obj = JSON.parse(payload);
      if(typeof obj === 'object') {
        payload = obj;
      }
    } catch (e) { }
  }

  //return header if `complete` option is enabled.  header includes claims
  //such as `kid` and `alg` used to select the key within a JWKS needed to
  //verify the signature
  if (options.complete === true) {
    return {
      header: decoded.header,
      payload: payload,
      signature: decoded.signature
    };
  }
  return payload;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...



var jws = require('jws');

module.exports = function (jwt, options) {
options = options || {};
var decoded = jws.<span class="apidocCodeKeywordSpan">decode</span>(jwt, options);
if (!decoded) { return null; }
var payload = decoded.payload;

//try parse the payload
if(typeof payload === 'string') {
  try {
    var obj = JSON.parse(payload);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonwebtoken.sign" id="apidoc.element.jsonwebtoken.sign">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>sign
        <span class="apidocSignatureSpan">(payload, secretOrPrivateKey, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (payload, secretOrPrivateKey, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  } else {
    options = options || {};
  }

  var isObjectPayload = typeof payload === 'object' &amp;&amp;
                        !Buffer.isBuffer(payload);

  var header = xtend({
    alg: options.algorithm || 'HS256',
    typ: isObjectPayload ? 'JWT' : undefined,
    kid: options.keyid
  }, options.header);

  function failure(err) {
    if (callback) {
      return callback(err);
    }
    throw err;
  }


  if (typeof payload === 'undefined') {
    return failure(new Error('payload is required'));
  } else if (isObjectPayload) {
    var payload_validation_result = registered_claims_schema.validate(payload);

    if (payload_validation_result.error) {
      return failure(payload_validation_result.error);
    }

    payload = xtend(payload);
  } else {
    var invalid_options = options_for_objects.filter(function (opt) {
      return typeof options[opt] !== 'undefined';
    });

    if (invalid_options.length &gt; 0) {
      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));
    }
  }

  if (typeof payload.exp !== 'undefined' &amp;&amp; typeof options.expiresIn !== 'undefined') {
    return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
  }

  if (typeof payload.nbf !== 'undefined' &amp;&amp; typeof options.notBefore !== 'undefined') {
    return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
  }

  var validation_result = sign_options_schema.validate(options);

  if (validation_result.error) {
    return failure(validation_result.error);
  }

  var timestamp = payload.iat || Math.floor(Date.now() / 1000);

  if (!options.noTimestamp) {
    payload.iat = timestamp;
  } else {
    delete payload.iat;
  }

  if (typeof options.notBefore !== 'undefined') {
    payload.nbf = timespan(options.notBefore);
    if (typeof payload.nbf === 'undefined') {
      return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }

  if (typeof options.expiresIn !== 'undefined' &amp;&amp; typeof payload === 'object') {
    payload.exp = timespan(options.expiresIn, timestamp);
    if (typeof payload.exp === 'undefined') {
      return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }

  Object.keys(options_to_payload).forEach(function (key) {
    var claim = options_to_payload[key];
    if (typeof options[key] !== 'undefined') {
      if (typeof payload[claim] !== 'undefined') {
        return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
      }
      payload[claim] = options[key];
    }
  });

  var encoding = options.encoding || 'utf8';

  if (typeof callback === 'function') {
    callback = callback &amp;&amp; once(callback);

    jws.createSign({
      header: header,
      privateKey: secretOrPrivateKey,
      payload: payload,
      encoding: encoding
    }).once('error', callback)
      .once('done', function (signature) {
        callback(null, signature);
      });
  } else {
    return jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```bash
$ npm install jsonwebtoken
```

# Usage

### jwt.<span class="apidocCodeKeywordSpan">sign</span>(payload, secretOrPrivateKey, [options, callback])

(Asynchronous) If a callback is supplied, callback is called with the `err` or the JWT.

(Synchronous) Returns the JsonWebToken as string

`payload` could be an object literal, buffer or string. *Please note that* `exp` is only set if the payload is an object literal
.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonwebtoken.verify" id="apidoc.element.jsonwebtoken.verify">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>verify
        <span class="apidocSignatureSpan">(jwtString, secretOrPublicKey, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (jwtString, secretOrPublicKey, options, callback) {
  if ((typeof options === 'function') &amp;&amp; !callback) {
    callback = options;
    options = {};
  }

  if (!options) {
    options = {};
  }

  //clone this object since we are going to mutate it.
  options = xtend(options);
  var done;

  if (callback) {
    done = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      return process.nextTick(function() {
        callback.apply(null, args);
      });
    };
  } else {
    done = function(err, data) {
      if (err) throw err;
      return data;
    };
  }

  if (options.clockTimestamp &amp;&amp; typeof options.clockTimestamp !== 'number') {
    return done(new JsonWebTokenError('clockTimestamp must be a number'));
  }

  var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);

  if (!jwtString){
    return done(new JsonWebTokenError('jwt must be provided'));
  }

  if (typeof jwtString !== 'string') {
    return done(new JsonWebTokenError('jwt must be a string'));
  }

  var parts = jwtString.split('.');

  if (parts.length !== 3){
    return done(new JsonWebTokenError('jwt malformed'));
  }

  var hasSignature = parts[2].trim() !== '';

  if (!hasSignature &amp;&amp; secretOrPublicKey){
    return done(new JsonWebTokenError('jwt signature is required'));
  }

  if (hasSignature &amp;&amp; !secretOrPublicKey) {
    return done(new JsonWebTokenError('secret or public key must be provided'));
  }

  if (!hasSignature &amp;&amp; !options.algorithms) {
    options.algorithms = ['none'];
  }

  if (!options.algorithms) {
    options.algorithms = ~secretOrPublicKey.toString().indexOf('BEGIN CERTIFICATE') ||
                         ~secretOrPublicKey.toString().indexOf('BEGIN PUBLIC KEY') ?
                          [ 'RS256','RS384','RS512','ES256','ES384','ES512' ] :
                         ~secretOrPublicKey.toString().indexOf('BEGIN RSA PUBLIC KEY') ?
                          [ 'RS256','RS384','RS512' ] :
                          [ 'HS256','HS384','HS512' ];

  }

  var decodedToken;
  try {
    decodedToken = jws.decode(jwtString);
  } catch(err) {
    return done(err);
  }

  if (!decodedToken) {
    return done(new JsonWebTokenError('invalid token'));
  }

  var header = decodedToken.header;

  if (!~options.algorithms.indexOf(header.alg)) {
    return done(new JsonWebTokenError('invalid algorithm'));
  }

  var valid;

  try {
    valid = jws.verify(jwtString, header.alg, secretOrPublicKey);
  } catch (e) {
    return done(e);
  }

  if (!valid)
    return done(new JsonWebTokenError('invalid signature'));

  var payload;

  try {
    payload = decode(jwtString);
  } catch(err) {
    return done(err);
  }

  if (typeof payload.nbf !== 'undefined' &amp;&amp; !options.ignoreNotBefore) {
    if (typeof payload.nbf !== 'number') {
      return done(new JsonWebTokenError('invalid nbf value'));
    }
    if (payload.nbf &gt; clockTimestamp + (options.clockTolerance || 0)) {
      return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));
    }
  }

  if (typeof payload.exp !== 'undefined' &amp;&amp; !options.ignoreExpiration) {
    if (typeof payload.exp !== 'number') {
      return done(new JsonWebTokenError('invalid exp value'));
    }
    if (clockTimestamp &gt;= payload.exp + (options.clockTolerance || 0)) {
      return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));
    }
  }

  if (options.audience) {
    var audiences = Array.isArray(options.audience)? options.audience : [options.audience];
    var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];

    var match = target.some(function(aud) { return audiences.indexOf(aud) != -1; });

    if (!match)
      return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));
  }

  if (options.issuer) {
    var invalid_issuer =
        (typeof options.issuer === 'string' &amp;&amp; payload.iss !== options.issuer) ||
        (Array.isArray(options.issuer) &amp;&amp; options.issuer.indexOf(payload.iss) === -1);

    if (invalid_issuer) {
      return done(new JsonWebTokenError('jwt issuer inv ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 https://github.com/auth0/node-jsonwebtoken/commit/24a370080e0b75f11d4717cd2b11b2949d95fc2e
 https://github.com/auth0/node-jsonwebtoken/commit/a77df6d49d4ec688dfd0a1cc723586bffe753516

### Security

- [verify] Update to jws@^3.0.0 and renaming `header.alg` mismatch exception to `invalid algorithm` and adding more mismatch tests
.

 As `jws@3.0.0` changed the verify method signature to be `jws.<span class="apidocCodeKeywordSpan">verify</span>(signature, algorithm
, secretOrKey)`, the token header must be decoded first in order to make sure that the `alg` field matches one of the allowed `options
.algorithms`. After that, the now validated `header.alg` is passed to `jws.verify`

As the order of steps has changed, the error that was thrown when the JWT was invalid is no longer the `jws` one:
```
{ [Error: Invalid token: no header in signature 'a.b.c'] code: 'MISSING_HEADER', signature: 'a.b.c'
; }
```

That old error (removed from jws) has been replaced by a `JsonWebTokenError` with message `invalid token`.
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonwebtoken.JsonWebTokenError" id="apidoc.module.jsonwebtoken.JsonWebTokenError">module jsonwebtoken.JsonWebTokenError</a></h1>


    <h2>
        <a href="#apidoc.element.jsonwebtoken.JsonWebTokenError.JsonWebTokenError" id="apidoc.element.jsonwebtoken.JsonWebTokenError.JsonWebTokenError">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>JsonWebTokenError
        <span class="apidocSignatureSpan">(message, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JsonWebTokenError = function (message, error) {
  Error.call(this, message);
  Error.captureStackTrace(this, this.constructor);
  this.name = 'JsonWebTokenError';
  this.message = message;
  if (error) this.inner = error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonwebtoken.JsonWebTokenError.prototype" id="apidoc.module.jsonwebtoken.JsonWebTokenError.prototype">module jsonwebtoken.JsonWebTokenError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsonwebtoken.JsonWebTokenError.prototype.constructor" id="apidoc.element.jsonwebtoken.JsonWebTokenError.prototype.constructor">
        function <span class="apidocSignatureSpan">jsonwebtoken.JsonWebTokenError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(message, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (message, error) {
  Error.call(this, message);
  Error.captureStackTrace(this, this.constructor);
  this.name = 'JsonWebTokenError';
  this.message = message;
  if (error) this.inner = error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonwebtoken.NotBeforeError" id="apidoc.module.jsonwebtoken.NotBeforeError">module jsonwebtoken.NotBeforeError</a></h1>


    <h2>
        <a href="#apidoc.element.jsonwebtoken.NotBeforeError.NotBeforeError" id="apidoc.element.jsonwebtoken.NotBeforeError.NotBeforeError">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>NotBeforeError
        <span class="apidocSignatureSpan">(message, date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotBeforeError = function (message, date) {
  JsonWebTokenError.call(this, message);
  this.name = 'NotBeforeError';
  this.date = date;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonwebtoken.NotBeforeError.prototype" id="apidoc.module.jsonwebtoken.NotBeforeError.prototype">module jsonwebtoken.NotBeforeError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsonwebtoken.NotBeforeError.prototype.constructor" id="apidoc.element.jsonwebtoken.NotBeforeError.prototype.constructor">
        function <span class="apidocSignatureSpan">jsonwebtoken.NotBeforeError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(message, date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (message, date) {
  JsonWebTokenError.call(this, message);
  this.name = 'NotBeforeError';
  this.date = date;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonwebtoken.TokenExpiredError" id="apidoc.module.jsonwebtoken.TokenExpiredError">module jsonwebtoken.TokenExpiredError</a></h1>


    <h2>
        <a href="#apidoc.element.jsonwebtoken.TokenExpiredError.TokenExpiredError" id="apidoc.element.jsonwebtoken.TokenExpiredError.TokenExpiredError">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>TokenExpiredError
        <span class="apidocSignatureSpan">(message, expiredAt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TokenExpiredError = function (message, expiredAt) {
  JsonWebTokenError.call(this, message);
  this.name = 'TokenExpiredError';
  this.expiredAt = expiredAt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonwebtoken.TokenExpiredError.prototype" id="apidoc.module.jsonwebtoken.TokenExpiredError.prototype">module jsonwebtoken.TokenExpiredError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsonwebtoken.TokenExpiredError.prototype.constructor" id="apidoc.element.jsonwebtoken.TokenExpiredError.prototype.constructor">
        function <span class="apidocSignatureSpan">jsonwebtoken.TokenExpiredError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(message, expiredAt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (message, expiredAt) {
  JsonWebTokenError.call(this, message);
  this.name = 'TokenExpiredError';
  this.expiredAt = expiredAt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>
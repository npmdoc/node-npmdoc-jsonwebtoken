<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/auth0/node-jsonwebtoken#readme">jsonwebtoken (v7.3.0)</a>
</h1>
<h4>JSON Web Token implementation (symmetric and asymmetric)</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonwebtoken">module jsonwebtoken</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.JsonWebTokenError">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>JsonWebTokenError
            <span class="apidocSignatureSpan">(message, error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.NotBeforeError">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>NotBeforeError
            <span class="apidocSignatureSpan">(message, date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.TokenExpiredError">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>TokenExpiredError
            <span class="apidocSignatureSpan">(message, expiredAt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.decode">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>decode
            <span class="apidocSignatureSpan">(jwt, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.sign">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>sign
            <span class="apidocSignatureSpan">(payload, secretOrPrivateKey, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.verify">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>verify
            <span class="apidocSignatureSpan">(jwtString, secretOrPublicKey, options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsonwebtoken.</span>JsonWebTokenError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsonwebtoken.</span>NotBeforeError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsonwebtoken.</span>TokenExpiredError.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonwebtoken.JsonWebTokenError">module jsonwebtoken.JsonWebTokenError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.JsonWebTokenError.JsonWebTokenError">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>JsonWebTokenError
            <span class="apidocSignatureSpan">(message, error)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonwebtoken.JsonWebTokenError.prototype">module jsonwebtoken.JsonWebTokenError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.JsonWebTokenError.prototype.constructor">
            function <span class="apidocSignatureSpan">jsonwebtoken.JsonWebTokenError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(message, error)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonwebtoken.NotBeforeError">module jsonwebtoken.NotBeforeError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.NotBeforeError.NotBeforeError">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>NotBeforeError
            <span class="apidocSignatureSpan">(message, date)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonwebtoken.NotBeforeError.prototype">module jsonwebtoken.NotBeforeError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.NotBeforeError.prototype.constructor">
            function <span class="apidocSignatureSpan">jsonwebtoken.NotBeforeError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(message, date)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonwebtoken.TokenExpiredError">module jsonwebtoken.TokenExpiredError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.TokenExpiredError.TokenExpiredError">
            function <span class="apidocSignatureSpan">jsonwebtoken.</span>TokenExpiredError
            <span class="apidocSignatureSpan">(message, expiredAt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonwebtoken.TokenExpiredError.prototype">module jsonwebtoken.TokenExpiredError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonwebtoken.TokenExpiredError.prototype.constructor">
            function <span class="apidocSignatureSpan">jsonwebtoken.TokenExpiredError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(message, expiredAt)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonwebtoken" id="apidoc.module.jsonwebtoken">module jsonwebtoken</a></h1>


    <h2>
        <a href="#apidoc.element.jsonwebtoken.JsonWebTokenError" id="apidoc.element.jsonwebtoken.JsonWebTokenError">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>JsonWebTokenError
        <span class="apidocSignatureSpan">(message, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JsonWebTokenError = function (message, error) {
  Error.call(this, message);
  Error.captureStackTrace(this, this.constructor);
  this.name = 'JsonWebTokenError';
  this.message = message;
  if (error) this.inner = error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonwebtoken.NotBeforeError" id="apidoc.element.jsonwebtoken.NotBeforeError">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>NotBeforeError
        <span class="apidocSignatureSpan">(message, date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotBeforeError = function (message, date) {
  JsonWebTokenError.call(this, message);
  this.name = 'NotBeforeError';
  this.date = date;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonwebtoken.TokenExpiredError" id="apidoc.element.jsonwebtoken.TokenExpiredError">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>TokenExpiredError
        <span class="apidocSignatureSpan">(message, expiredAt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TokenExpiredError = function (message, expiredAt) {
  JsonWebTokenError.call(this, message);
  this.name = 'TokenExpiredError';
  this.expiredAt = expiredAt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonwebtoken.decode" id="apidoc.element.jsonwebtoken.decode">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>decode
        <span class="apidocSignatureSpan">(jwt, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decode = function (jwt, options) {
  options = options || {};
  var decoded = jws.decode(jwt, options);
  if (!decoded) { return null; }
  var payload = decoded.payload;

  //try parse the payload
  if(typeof payload === 'string') {
    try {
      var obj = JSON.parse(payload);
      if(typeof obj === 'object') {
        payload = obj;
      }
    } catch (e) { }
  }

  //return header if `complete` option is enabled.  header includes claims
  //such as `kid` and `alg` used to select the key within a JWKS needed to
  //verify the signature
  if (options.complete === true) {
    return {
      header: decoded.header,
      payload: payload,
      signature: decoded.signature
    };
  }
  return payload;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var cert = fs.readFileSync('public.pem'); // get public key
jwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {
  // if token alg != RS256,  err == invalid signature
});

```

### jwt.<span class="apidocCodeKeywordSpan">decode</span>(token [, options])

(Synchronous) Returns the decoded payload without verifying if the signature is valid.

__Warning:__ This will __not__ verify whether the signature is valid. You should __not__ use this for untrusted messages. You most
 likely want to use `jwt.verify` instead.

`token` is the JsonWebToken string
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonwebtoken.sign" id="apidoc.element.jsonwebtoken.sign">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>sign
        <span class="apidocSignatureSpan">(payload, secretOrPrivateKey, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sign = function (payload, secretOrPrivateKey, options, callback) {
  options = options || {};

  var isObjectPayload = typeof payload === 'object' &amp;&amp;
                        !Buffer.isBuffer(payload);

  var header = xtend({
    alg: options.algorithm || 'HS256',
    typ: isObjectPayload ? 'JWT' : undefined,
    kid: options.keyid
  }, options.header);

  function failure(err) {
    if (callback) {
      return callback(err);
    }
    throw err;
  }


  if (typeof payload === 'undefined') {
    return failure(new Error('payload is required'));
  } else if (isObjectPayload) {
    var payload_validation_result = registered_claims_schema.validate(payload);

    if (payload_validation_result.error) {
      return failure(payload_validation_result.error);
    }

    payload = xtend(payload);
  } else {
    var invalid_options = options_for_objects.filter(function (opt) {
      return typeof options[opt] !== 'undefined';
    });

    if (invalid_options.length &gt; 0) {
      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));
    }
  }

  if (typeof payload.exp !== 'undefined' &amp;&amp; typeof options.expiresIn !== 'undefined') {
    return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
  }

  if (typeof payload.nbf !== 'undefined' &amp;&amp; typeof options.notBefore !== 'undefined') {
    return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
  }

  var validation_result = sign_options_schema.validate(options);

  if (validation_result.error) {
    return failure(validation_result.error);
  }

  var timestamp = payload.iat || Math.floor(Date.now() / 1000);

  if (!options.noTimestamp) {
    payload.iat = timestamp;
  } else {
    delete payload.iat;
  }

  if (typeof options.notBefore !== 'undefined') {
    payload.nbf = timespan(options.notBefore);
    if (typeof payload.nbf === 'undefined') {
      return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }

  if (typeof options.expiresIn !== 'undefined' &amp;&amp; typeof payload === 'object') {
    payload.exp = timespan(options.expiresIn, timestamp);
    if (typeof payload.exp === 'undefined') {
      return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
    }
  }

  Object.keys(options_to_payload).forEach(function (key) {
    var claim = options_to_payload[key];
    if (typeof options[key] !== 'undefined') {
      if (typeof payload[claim] !== 'undefined') {
        return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
      }
      payload[claim] = options[key];
    }
  });

  var encoding = options.encoding || 'utf8';

  if (typeof callback === 'function') {
    callback = callback &amp;&amp; once(callback);

    jws.createSign({
      header: header,
      privateKey: secretOrPrivateKey,
      payload: payload,
      encoding: encoding
    }).once('error', callback)
      .once('done', function (signature) {
        callback(null, signature);
      });
  } else {
    return jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```bash
$ npm install jsonwebtoken
```

# Usage

### jwt.<span class="apidocCodeKeywordSpan">sign</span>(payload, secretOrPrivateKey, options, [callback])

(Asynchronous) If a callback is supplied, callback is called with the `err` or the JWT.

(Synchronous) Returns the JsonWebToken as string

`payload` could be an object literal, buffer or string. *Please note that* `exp` is only set if the payload is an object literal
.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonwebtoken.verify" id="apidoc.element.jsonwebtoken.verify">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>verify
        <span class="apidocSignatureSpan">(jwtString, secretOrPublicKey, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verify = function (jwtString, secretOrPublicKey, options, callback) {
  if ((typeof options === 'function') &amp;&amp; !callback) {
    callback = options;
    options = {};
  }

  if (!options) {
    options = {};
  }

  //clone this object since we are going to mutate it.
  options = xtend(options);
  var done;

  if (callback) {
    done = function() {
      var args = Array.prototype.slice.call(arguments, 0);
      return process.nextTick(function() {
        callback.apply(null, args);
      });
    };
  } else {
    done = function(err, data) {
      if (err) throw err;
      return data;
    };
  }

  if (options.clockTimestamp &amp;&amp; typeof options.clockTimestamp !== 'number') {
    return done(new JsonWebTokenError('clockTimestamp must be a number'));
  }

  var clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);

  if (!jwtString){
    return done(new JsonWebTokenError('jwt must be provided'));
  }

  if (typeof jwtString !== 'string') {
    return done(new JsonWebTokenError('jwt must be a string'));
  }

  var parts = jwtString.split('.');

  if (parts.length !== 3){
    return done(new JsonWebTokenError('jwt malformed'));
  }

  var hasSignature = parts[2].trim() !== '';

  if (!hasSignature &amp;&amp; secretOrPublicKey){
    return done(new JsonWebTokenError('jwt signature is required'));
  }

  if (hasSignature &amp;&amp; !secretOrPublicKey) {
    return done(new JsonWebTokenError('secret or public key must be provided'));
  }

  if (!hasSignature &amp;&amp; !options.algorithms) {
    options.algorithms = ['none'];
  }

  if (!options.algorithms) {
    options.algorithms = ~secretOrPublicKey.toString().indexOf('BEGIN CERTIFICATE') ||
                         ~secretOrPublicKey.toString().indexOf('BEGIN PUBLIC KEY') ?
                          [ 'RS256','RS384','RS512','ES256','ES384','ES512' ] :
                         ~secretOrPublicKey.toString().indexOf('BEGIN RSA PUBLIC KEY') ?
                          [ 'RS256','RS384','RS512' ] :
                          [ 'HS256','HS384','HS512' ];

  }

  var decodedToken;
  try {
    decodedToken = jws.decode(jwtString);
  } catch(err) {
    return done(err);
  }

  if (!decodedToken) {
    return done(new JsonWebTokenError('invalid token'));
  }

  var header = decodedToken.header;

  if (!~options.algorithms.indexOf(header.alg)) {
    return done(new JsonWebTokenError('invalid algorithm'));
  }

  var valid;

  try {
    valid = jws.verify(jwtString, header.alg, secretOrPublicKey);
  } catch (e) {
    return done(e);
  }

  if (!valid)
    return done(new JsonWebTokenError('invalid signature'));

  var payload;

  try {
    payload = decode(jwtString);
  } catch(err) {
    return done(err);
  }

  if (typeof payload.nbf !== 'undefined' &amp;&amp; !options.ignoreNotBefore) {
    if (typeof payload.nbf !== 'number') {
      return done(new JsonWebTokenError('invalid nbf value'));
    }
    if (payload.nbf &gt; clockTimestamp + (options.clockTolerance || 0)) {
      return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));
    }
  }

  if (typeof payload.exp !== 'undefined' &amp;&amp; !options.ignoreExpiration) {
    if (typeof payload.exp !== 'number') {
      return done(new JsonWebTokenError('invalid exp value'));
    }
    if (clockTimestamp &gt;= payload.exp + (options.clockTolerance || 0)) {
      return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));
    }
  }

  if (options.audience) {
    var audiences = Array.isArray(options.audience)? options.audience : [options.audience];
    var target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];

    var match = target.some(function(aud) { return audiences.indexOf(aud) != -1; });

    if (!match)
      return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));
  }

  if (options.issuer) {
    var invalid_issuer =
        (typeof options.issuer === 'string' &amp;&amp; payload.iss !== options.issuer) ||
        (Array.isArray(options.issuer) &amp;&amp; options.issuer.indexOf(payload.iss) === -1);

    if (invalid_issuer) {
      return done(new JsonWebTokenError('jwt issuer inv ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//or even better:

jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: '1h' });
```

### jwt.<span class="apidocCodeKeywordSpan">verify</span>(token, secretOrPublicKey, [options, callback])

(Asynchronous) If a callback is supplied, function acts asynchronously. Callback is passed the decoded payload if the signature
and optional expiration, audience, or issuer are valid. If not, it will be passed the error.

(Synchronous) If a callback is not supplied, function acts synchronously. Returns the payload decoded if the signature (and, optionally
, expiration, audience, issuer) are valid. If not, it will throw the error.

`token` is the JsonWebToken string
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonwebtoken.JsonWebTokenError" id="apidoc.module.jsonwebtoken.JsonWebTokenError">module jsonwebtoken.JsonWebTokenError</a></h1>


    <h2>
        <a href="#apidoc.element.jsonwebtoken.JsonWebTokenError.JsonWebTokenError" id="apidoc.element.jsonwebtoken.JsonWebTokenError.JsonWebTokenError">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>JsonWebTokenError
        <span class="apidocSignatureSpan">(message, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">JsonWebTokenError = function (message, error) {
  Error.call(this, message);
  Error.captureStackTrace(this, this.constructor);
  this.name = 'JsonWebTokenError';
  this.message = message;
  if (error) this.inner = error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonwebtoken.JsonWebTokenError.prototype" id="apidoc.module.jsonwebtoken.JsonWebTokenError.prototype">module jsonwebtoken.JsonWebTokenError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsonwebtoken.JsonWebTokenError.prototype.constructor" id="apidoc.element.jsonwebtoken.JsonWebTokenError.prototype.constructor">
        function <span class="apidocSignatureSpan">jsonwebtoken.JsonWebTokenError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(message, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (message, error) {
  Error.call(this, message);
  Error.captureStackTrace(this, this.constructor);
  this.name = 'JsonWebTokenError';
  this.message = message;
  if (error) this.inner = error;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonwebtoken.NotBeforeError" id="apidoc.module.jsonwebtoken.NotBeforeError">module jsonwebtoken.NotBeforeError</a></h1>


    <h2>
        <a href="#apidoc.element.jsonwebtoken.NotBeforeError.NotBeforeError" id="apidoc.element.jsonwebtoken.NotBeforeError.NotBeforeError">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>NotBeforeError
        <span class="apidocSignatureSpan">(message, date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotBeforeError = function (message, date) {
  JsonWebTokenError.call(this, message);
  this.name = 'NotBeforeError';
  this.date = date;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonwebtoken.NotBeforeError.prototype" id="apidoc.module.jsonwebtoken.NotBeforeError.prototype">module jsonwebtoken.NotBeforeError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsonwebtoken.NotBeforeError.prototype.constructor" id="apidoc.element.jsonwebtoken.NotBeforeError.prototype.constructor">
        function <span class="apidocSignatureSpan">jsonwebtoken.NotBeforeError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(message, date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (message, date) {
  JsonWebTokenError.call(this, message);
  this.name = 'NotBeforeError';
  this.date = date;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonwebtoken.TokenExpiredError" id="apidoc.module.jsonwebtoken.TokenExpiredError">module jsonwebtoken.TokenExpiredError</a></h1>


    <h2>
        <a href="#apidoc.element.jsonwebtoken.TokenExpiredError.TokenExpiredError" id="apidoc.element.jsonwebtoken.TokenExpiredError.TokenExpiredError">
        function <span class="apidocSignatureSpan">jsonwebtoken.</span>TokenExpiredError
        <span class="apidocSignatureSpan">(message, expiredAt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TokenExpiredError = function (message, expiredAt) {
  JsonWebTokenError.call(this, message);
  this.name = 'TokenExpiredError';
  this.expiredAt = expiredAt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonwebtoken.TokenExpiredError.prototype" id="apidoc.module.jsonwebtoken.TokenExpiredError.prototype">module jsonwebtoken.TokenExpiredError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsonwebtoken.TokenExpiredError.prototype.constructor" id="apidoc.element.jsonwebtoken.TokenExpiredError.prototype.constructor">
        function <span class="apidocSignatureSpan">jsonwebtoken.TokenExpiredError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(message, expiredAt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (message, expiredAt) {
  JsonWebTokenError.call(this, message);
  this.name = 'TokenExpiredError';
  this.expiredAt = expiredAt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>